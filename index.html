<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 Smooth Pro</title>
    <style>
        :root {
            --bg-color: #faf8ef;
            --grid-bg: #bbada0;
            --cell-bg: rgba(238, 228, 218, 0.35);
            --text-dark: #776e65;
            --text-light: #f9f6f2;
            --tile-size: 72.5px;
            --tile-gap: 10px;
        }

        body {
            background-color: var(--bg-color);
            font-family: "Clear Sans", sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; margin: 0; overflow: hidden; touch-action: none;
        }

        .container { width: 340px; }
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        h1 { font-size: 55px; font-weight: bold; color: var(--text-dark); margin: 0; }

        .score-box {
            background: var(--grid-bg); padding: 5px 15px; border-radius: 4px;
            color: white; text-align: center; min-width: 50px;
        }
        .score-label { font-size: 11px; text-transform: uppercase; font-weight: bold; display: block; }
        .score-value { font-size: 20px; font-weight: bold; }

        .game-area {
            position: relative; padding: var(--tile-gap); background: var(--grid-bg);
            border-radius: 6px; width: 340px; height: 340px; box-sizing: border-box;
        }

        .grid-bg { display: grid; grid-template-columns: repeat(4, 1fr); grid-gap: var(--tile-gap); }
        .grid-cell { width: var(--tile-size); height: var(--tile-size); background: var(--cell-bg); border-radius: 3px; }

        .tile-container { position: absolute; top: 10px; left: 10px; z-index: 2; }

        .tile {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            border-radius: 3px;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 32px;
            /* This transition is what makes it slide */
            transition: transform 120ms ease-in-out; 
            z-index: 10;
        }

        /* Value Styling */
        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #ede0c8; color: #776e65; }
        .tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile-16 { background: #f59563; color: #f9f6f2; }
        .tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile-64 { background: #f65e3b; color: #f9f6f2; }
        .tile-128 { background: #edcf72; color: #f9f6f2; font-size: 28px; box-shadow: 0 0 10px #edcf72; }
        .tile-256 { background: #edcc61; color: #f9f6f2; font-size: 28px; box-shadow: 0 0 12px #edcc61; }
        .tile-512 { background: #edc850; color: #f9f6f2; font-size: 28px; }
        .tile-1024 { background: #edc53f; color: #f9f6f2; font-size: 22px; }
        .tile-2048 { background: #edc22e; color: #f9f6f2; font-size: 22px; }

        .tile-new { animation: appear 200ms ease-out; }
        .tile-merged { z-index: 20; animation: pop 150ms ease-in-out; }

        @keyframes appear { from { opacity: 0; transform: scale(0); } to { opacity: 1; transform: scale(1); } }
        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

        #game-message {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(238, 228, 218, 0.8); z-index: 100;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 6px;
        }
        #game-message p { font-size: 45px; font-weight: bold; color: #776e65; margin-bottom: 20px; }
        .btn { background: #8f7a66; color: white; border: none; padding: 12px 25px; border-radius: 3px; font-weight: bold; cursor: pointer; font-size: 18px; }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>2048</h1>
            <div style="display:flex; gap:5px">
                <div class="score-box"><span class="score-label">Score</span><div id="score" class="score-value">0</div></div>
                <div class="score-box"><span class="score-label">Best</span><div id="best" class="score-value">0</div></div>
            </div>
        </header>

        <div class="game-area">
            <div id="game-message">
                <p id="status-text">Game Over!</p>
                <button class="btn" onclick="game.setup()">Try Again</button>
            </div>
            <div class="grid-bg">
                <script>for(let i=0; i<16; i++) document.write('<div class="grid-cell"></div>');</script>
            </div>
            <div id="tile-container" class="tile-container"></div>
        </div>

        <div style="margin-top:20px; display:flex; justify-content:space-between; align-items:center;">
            <p style="color:#776e65; font-weight:bold; margin:0;">Swipe or use Arrows</p>
            <button class="btn" onclick="game.setup()">New Game</button>
        </div>
    </div>

    <script>
        class Tile {
            constructor(pos, val) {
                this.pos = pos;
                this.val = val;
                this.id = Math.random(); // Unique ID to track the element
                this.element = this.createHTMLElement();
            }

            createHTMLElement() {
                const el = document.createElement('div');
                el.className = `tile tile-${this.val} tile-new`;
                el.textContent = this.val;
                this.updatePosition(el);
                return el;
            }

            updatePosition(el = this.element) {
                const x = (this.pos % 4) * 82.5;
                const y = Math.floor(this.pos / 4) * 82.5;
                el.style.transform = `translate(${x}px, ${y}px)`;
            }

            updateValue() {
                this.element.className = `tile tile-${this.val} tile-merged`;
                this.element.textContent = this.val;
            }
        }

        class Game2048 {
            constructor() {
                this.container = document.getElementById('tile-container');
                this.bestDisplay = document.getElementById('best');
                this.scoreDisplay = document.getElementById('score');
                this.bestScore = localStorage.getItem('best2048') || 0;
                this.bestDisplay.innerText = this.bestScore;
                this.setup();
                this.initControls();
            }

            setup() {
                this.grid = Array(16).fill(null);
                this.score = 0;
                this.over = false;
                this.container.innerHTML = '';
                document.getElementById('game-message').style.display = 'none';
                this.updateScore(0);
                this.addTile();
                this.addTile();
            }

            addTile() {
                const empty = this.grid.map((v, i) => v === null ? i : null).filter(v => v !== null);
                if (empty.length) {
                    const pos = empty[Math.floor(Math.random() * empty.length)];
                    const tile = new Tile(pos, Math.random() < 0.9 ? 2 : 4);
                    this.grid[pos] = tile;
                    this.container.appendChild(tile.element);
                }
            }

            move(dir) {
                if (this.over) return;
                let moved = false;
                const vectors = { 'up': [-1,0], 'down': [1,0], 'left': [0,-1], 'right': [0,1] };
                const v = vectors[dir];
                
                let rows = [0,1,2,3], cols = [0,1,2,3];
                if (dir === 'down') rows.reverse();
                if (dir === 'right') cols.reverse();

                let mergedIds = new Set();

                rows.forEach(r => {
                    cols.forEach(c => {
                        let i = r * 4 + c;
                        let tile = this.grid[i];
                        if (!tile) return;

                        let currR = r, currC = c;
                        while (true) {
                            let nextR = currR + v[0], nextC = currC + v[1];
                            let nextI = nextR * 4 + nextC;

                            if (nextR>=0 && nextR<4 && nextC>=0 && nextC<4) {
                                let nextTile = this.grid[nextI];
                                if (!nextTile) {
                                    // Slide into empty space
                                    this.grid[nextI] = tile;
                                    this.grid[currR * 4 + currC] = null;
                                    currR = nextR; currC = nextC;
                                    tile.pos = nextI;
                                    tile.updatePosition();
                                    moved = true;
                                } else if (nextTile.val === tile.val && !mergedIds.has(nextTile.id)) {
                                    // Merge
                                    nextTile.val *= 2;
                                    this.updateScore(nextTile.val);
                                    mergedIds.add(nextTile.id);
                                    
                                    // Slide tile into the other and then remove it
                                    tile.pos = nextI;
                                    tile.updatePosition();
                                    const oldTileEl = tile.element;
                                    setTimeout(() => oldTileEl.remove(), 100);
                                    
                                    nextTile.updateValue();
                                    this.grid[currR * 4 + currC] = null;
                                    moved = true;
                                    break;
                                } else break;
                            } else break;
                        }
                    });
                });

                if (moved) {
                    setTimeout(() => {
                        this.addTile();
                        if (!this.canMove()) this.end(false);
                    }, 120);
                }
            }

            updateScore(pts) {
                this.score += pts;
                this.scoreDisplay.innerText = this.score;
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    this.bestDisplay.innerText = this.bestScore;
                    localStorage.setItem('best2048', this.bestScore);
                }
            }

            canMove() {
                if (this.grid.includes(null)) return true;
                for (let i=0; i<16; i++) {
                    let r = Math.floor(i/4), c = i%4;
                    if (c<3 && this.grid[i].val === this.grid[i+1].val) return true;
                    if (r<3 && this.grid[i].val === this.grid[i+4].val) return true;
                }
                return false;
            }

            end(win) {
                this.over = true;
                document.getElementById('status-text').innerText = win ? "You Win!" : "Game Over!";
                document.getElementById('game-message').style.display = 'flex';
            }

            initControls() {
                window.addEventListener('keydown', e => {
                    if (e.key.includes('Arrow')) { e.preventDefault(); this.move(e.key.replace('Arrow','').toLowerCase()); }
                });
                let tx, ty;
                window.addEventListener('touchstart', e => { tx = e.touches[0].clientX; ty = e.touches[0].clientY; });
                window.addEventListener('touchend', e => {
                    let dx = e.changedTouches[0].clientX - tx, dy = e.changedTouches[0].clientY - ty;
                    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) this.move(dx > 0 ? 'right' : 'left');
                    else if (Math.abs(dy) > 30) this.move(dy > 0 ? 'down' : 'up');
                });
            }
        }
        const game = new Game2048();
    </script>
</body>
</html>
